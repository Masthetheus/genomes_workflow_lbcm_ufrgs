% Genomes Workflow Module Template - LBCM UFRGS
% Based on NotesTeX and Gilles Castel's aesthetic approach
% Module: 01 - General guidelines and workflow organization
% Date: DATE_PLACEHOLDER

\documentclass[a4paper,11pt]{article}

% Use ONLY the beautiful notes preamble for notes
\input{preamble.tex}

\title{
    \vfill
    \textcolor{noteblue}{\Huge Genomes Workflow - LBCM}\\
    \vspace{5.0cm}
    \textcolor{sidenotegray}{\huge 01 - General guidelines and workflow organization}\\
    \vspace{1.5cm}
    \textcolor{sidenotegray}{\LARGE }\\
    \vspace{5.0cm}
    \textcolor{sidenotegray}{\large \today}
    \vfill
}
\author{}
\date{}

\begin{document}

\maketitle
\thispagestyle{empty}
\newpage
\tableofcontents
\newpage
\section{Overview}

\subsection{Module Objectives}
\sn{Learning goals}

This module covers:
\begin{itemize}
    \item Basic Linux terminal concepts and usage.
    \item What is git and basic usage.
    \item Conda environment logic.
    \item Conda basic usage.
    \item Recommended bioinformatics project organization.
\end{itemize}

\section{The Linux question}
Taking in consideration the variety of tools available, their functionalities
and general comprehension around systems and workflow organization, the choice
of operational system constitutes a central point. \par 
In multiple fronts, Linux get's the spotlight. One big advantage is the cost to
install and implement the OS: Zero. With a GPL License, everyone has the right
to change and redistribute it, following the condition that the code should stay
available (\cite{garrelsIntroductionLinux2008}). It's portability, security and
the existence of a large and committed community all helps on the final OS
choice for general Bioinformatics research projects.\par
In the current chapter, we intend to present basics concepts of the Linux
ecosystem. Terminal operation will also be included, since it's intrinsic
relation to the system core functionalities. Finally, a brief Linux Mint
presentation and guidelines shall be pointed, as it's the initial distro of
choice.\par
\begin{remarkbox}
    For further and in depth comprehension of base Linux related topics, it is
    advised to check \cite{garrelsIntroductionLinux2008}.
\end{remarkbox}
\subsection{So... What is it?}
With the crescent wave on tech development, the fact that some systems were
directly developed for specific hardware started to weight a ton on user
instruction and final cost of the products. A team of developers then started
working on what would come to be the \textbf{"UNIX"} project. This operational system
brought to the table the ability of code to be recycled, the use of
a higher programming language then assembly (C) and an unique overall
simplicity (\cite{garrelsIntroductionLinux2008}).\par
\begin{definitionbox}
   UNIX refers to a family of operational systems based on the final product of
   the original UNIX project. They aim to be simple, elegant and allow code
   recycling. To achieve their goals, modular logic is applied, alongside
   a hierarchical file system and innate command line interface. 
\end{definitionbox}
Then, home PC's started getting traction, in a way that running UNIX on them
became a possibility. In this context, the idea of a free system directly
connected to the original \textbf{UNIX} would led to the birth of \textbf{Linux}
as a freely available OS.
\begin{definitionbox}
    Linux is an open source OS based on UNIX. Is composed mainly by
    (\cite{WhatLinux2025}):
    \begin{description}
        \item[Bootloader:] Manages the boot process of the computer.
        \item[Kernel:] The actual \textbf{Linux}. Manages the CPU, memory and
            peripheral devices.
        \item[Initialization system:] Sub-system that controls daemons.
        \item[Daemons:] Background services started up during or after boot.
        \item[Graphical server:] Sub-system for graphical display.
        \item[Desktop environment:] Interfaces for direct user interaction.
        \item[Applications:] Any software that can be installed on the system
            and offer some service or act as a tool.
    \end{description}
\end{definitionbox}
\subsection{Choosing a Distro}
A lifelong debates inside the Linux community revolves around which  Linux
distribution to choose. One of the biggest reasons for such is that there's no
correct answer. Multiple factors interfere in the final choice, and it can be
largely personal too.\par
Across the internet, a variety of guides and lists can be found on the subject.
As it's not the central purpose of this project, we won't dive deeply in this
matter. But, even though this creative freedom was taken, we will still, in
a further chapter, approach one specific Linux distro, called Linux Mint. This
decision was made to lay a foundation for some installation instructions, that
can change based on the system of choice. Always when that's the case, it shall
be pointed out.\par
The choice of Mint itself was based purely on the fact that it is a distro with
large support, reach and with a more reasonable learning curve for Linux
newcomers.

\begin{tipbox}
    If you want to dive a little deeper on the Mint Distro, we recommend it's
    User Guide (\cite{mintUserGuideLinux2024}). In it, you can find informations
    on the system's update manager, multiboot, upgrades from older versions and
    so on. The online official documentation Linux Mint webpage presents in
    multiple format all available guides (\cite{mintLinuxMintDocumentation2025}). 
\end{tipbox}

\subsection{Installing The Chosen One}
An encouraged practice when making a software available is to always provide
an in depth documentation on it. One can assume, then, that almost every, if not
all, chosen Linux distribution has a guide to system installation and usage.
Taking this in mind, the current project will describe in general lines the
basic needs to install a distro, with some key concepts and necessary tools,
avoiding redundancy with the material the system itself has.
\subsubsection{Before anything...}
When faced with the idea to change the current OS to a Linux distro, before
major definitive modifications are made, some safety measures are encouraged.
The central point is to make sure that everything runs smoothly, and avoid
system breaking errors and data loss as much as possible. In this project, we
joined some general measures, presented below.

\begin{description}
\item[Applications list:] The majority of bioinformatics software is designed
    with Linux based systems in mind, or provides a compatible version. But,
    it's recommended to make a list of the main needs and goals of the operator
    with the system to facilitate the post-install and prevent incompatibility
    issues.
\begin{tipbox}
This list can also be used to help in choosing the distro that fits your needs
the best.
\end{tipbox}
\item[Backup:] Always backup crucial files.
\item[Driver support:] It's a good practice to check also if external drivers of
    daily and necessary use have functional drivers for Linux based systems.
\item[System requirements:] Check beforehand if your current hardware
    specifications match at least the minimum requirements of the chosen distro.
    Usually this information can be found in the main webpage of the OS.
\item[Tool and Applications support:] Although a lot of software nowadays is
    developed with Linux compatibility in mind, that's not always the case. Some
    services like the Microsoft Office Package and the Adobe Suite don't have
    a secure and optimal distribution for Linux based systems, making their
    usage impossible, impractical or unreliable.
\end{description}
After considering the items listed above, you can better decide which path to
take.
\begin{tipbox}
If you aren't yet secure of moving totally to Linux, you can set up a Dual Boot
function with your current OS and your distro of choice. You can also use
a Virtual Machine to emulate a Linux environment and use the OS from inside it!
\end{tipbox}
\subsubsection{Tools}
In the majority of cases, not much is needed to proceed with a Linux OS
installation. Usually, it sums up to:
\begin{description}
    \item [Bootable device:] A storage medium containing the core files for the
        installation of the chosen distro. Usually consists on the medium with
        the chosen system's ISO file "flashed" into.
    \item [Image writer:] A dedicated software that is able to correctly flash
        a storage device with an system image, turning it into a bootable
        device.
    \item [ISO file:] Is a file on the ISO format that contains the necessary
        structure, directions and files for the correct system installation.
\end{description}
\begin{definitionbox}
    \textbf{Flashing:} Consists on taking an ISO image and transferring all the
    partitions, file systems and files that were present on the device used to
    create the image.\par 
    \textbf{ISO format:} The ISO format can be seen as the equivalent of replicating
        the contents and structure of a CD, DVD or even a Blu-Ray disc.\par 
        \textbf{Storage device:} An external drive that can be used as a storage
        medium, e.g. an USB flash drive.  
\end{definitionbox}
\subsubsection{Validating the ISO}
As we can infer, given the above definitions, the process basically consists on
taking the target OS general structure and files, flashing it into the bootable
device and using the latter to build the system on the machine. Thus, we can
logically infer, the success of the operation relies heavily on the integrity of
the ISO file, as it represents what will be installed.\par
To avoid the task of manually reviewing, we have more automated means to check
integrity. For that, in the majority of cases, we can use SHA256 sums to
complete this task. The usual workflow for such is:
\begin{enumerate}
    \item Download the correct sha256sum.txt and sha256sum.txt.gpg files
        according to the chosen distro and version.\par
        \textbf{Obs:} Make sure to download the files themselves, and not just
        copy and paste their content on a new file.
    \item Open a terminal window where the downloaded sha256sum.txt file is, or
        navigate to the location.
    \item If on a Linux system, verify the \textbf{integrity} with:
\begin{lstlisting}[language=bash]
sha256sum -b chosendistro.iso
# Or, if the iso is on another location
sha256sum -b /path/to/chosendistro.iso
\end{lstlisting}
    \begin{remarkbox}
        On macOS, the command structure is similar, although the command itself
        is only \textbf{shasum}. But, if you are currently using Windows, the
        process follows a distinct path. If that's the case, we recommend
        checking the guide available on the
        \href{https://forums.linuxmint.com/viewtopic.php?f=42&t=291093}{Linux
        Mint Forum}, that approaches the problem at hand. 
    \end{remarkbox}
    \item If both match, the ISO image was successfully downloaded. If not, it's
        advisable to re-download the file.
        \begin{tipbox}
            Before downloading the ISO again, it's always worth the shot to
            check a second time if the correct hash file is being tested, that
            being, the hash for the same distro and same distro version chosen.
        \end{tipbox}
\end{enumerate}
\begin{remarkbox}
    The shum files are usually provided with the ISO download or can be
    retrieved in the same page as the main download mirror.\par
    If you wish to further comprehend what the SHA hash is and how it allows
    data verification, we recommend the quick post available at
    \href{https://www.howtogeek.com/67241/htg-explains-what-are-md5-sha-1-hashes-and-how-do-i-check-them/}{How
    to Geek.}
   
\end{remarkbox}
Okay, the file is intact. But, how do we know that the hash file used to test
it's integrity is really authentic, and wasn't corrupted or altered? Simple,
checking it's authenticity. In the case of Linux Mint, it goes as follow
(\cite{mintInstallationGuide2024}):
\begin{enumerate}
    \item Import the Linux Mint signing key.
        \begin{lstlisting}[language=bash]
gpg --keyserver hkp://keys.openpgp.org:80 --recv-key \
27DEB15644C6B3CF3BD7D291300F846BA25BAE09    
\end{lstlisting}
    \item Check key importation:
\begin{lstlisting}[language=bash]
gpg --list-key --with-fingerprint A25BAE09\end{lstlisting}
    \item Confirm that the output from the previous command presents the key
        informed on the first command used and the relation to Linux Mint.
    \item Check the authenticity with:
\begin{lstlisting}[language=bash]
gpg --verify sha256sum.txt.gpg sha256sum.txt
\end{lstlisting}
    \item If the output points that the signature is good and was made with the
        key imported, the test was passed.
\end{enumerate}
\begin{tipbox}
\begin{description}
\item[PATH:] Make sure that all files informed on the commands are on the
    current work directory of the opened terminal. If not, you can either change
    the terminal WD, the files location or specify the full path to the files on
    the commands.
\item[GPG warning:] The GPG may send a warn that the signature isn't trusted by
    the computer, this is expected and normal. 
\end{description}
\end{tipbox}
\subsubsection{Process Overview}
A full installation guide can usually be found on your distro of choice
homepage. It usually covers all the needed steps and present FAQ's to help with
following them.
\href{https://linuxmint-installation-guide.readthedocs.io/en/latest/}{Here} 
you can see the documentation for installing Linux Mint.
The process has similar features for all distros:
\begin{enumerate}
    \item Choose and download the intended version.
    \item Verify the ISO integrity.
    \item Create the bootable device.
    \item Insert the bootable media onto your machine and boot from it (Usually
        accessing the BIOS and changing boot order).
    \item Enter the system.
    \item Start the installation setup and follow the steps pointed.
    \item Reboot the machine.
    \item Remove the bootable device.
\end{enumerate}
The new OS is almost completely ready to use!
\begin{tipbox}
Most Linux distributions allow the user to test the system before fully
installing via the bootable device.
\end{tipbox}
\subsubsection{Aftermath}


\subsection{Command Line and Terminal operation}
When using Linux based OS's, one specific "feature" get's the spotlight on the
eyes of newcomers: the command line. Basically all tasks done via GUI's can be
also executed via command line, usually mediated with a terminal interface.\par
Taking this in mind, understanding the relevance and basic navigation of the
command line, allows an overall better and more efficient system operation. In
this sense, the present section aims to establish broad concepts and present
general guidelines on the subject.
\begin{definitionbox}
    The term command line, actually refers to the \textbf{shell}. It consists in
    a program whose purpose is to take keyboard commands and direct them to the
    OS for execution. In Linux systems, the core \textbf{shell} usually is
    \textbf{bash}. \textbf{Terminals} are interfaces that allow users with a GUI to
    interact with the \textbf{shell}(\cite{shottsLinuxCommandLine2024}).
\end{definitionbox}
\subsubsection{Basics}
Nothing better to learn than getting punched by the subject. Let's experiment
with basic terminal manipulation and usage. This section is an adaptation of the
first chapter of \cite{shotssLinuxCommandLine2024}, in that sense, for further
comprehension on the subject, please refer to the main source.\par
First, open the terminal window (Ctrl+Alt+T on Linux Mint). What you are now
seeing, I hope so, is something like:
\begin{lstlisting}[language=bash]
   [user@machine ~]$ 
\end{lstlisting}
Or, if using conda, probably something like:
\begin{lstlisting}[language=bash]
   (base)[user@machine ~]$ 
\end{lstlisting}
This is what we call the shell prompt, indicating that it's ready to receive
orders. It informs you the current user name, the machine name and the current
directory. Knowledge of the directory currently set is of extreme importance,
and will be discussed on the next topic.\par
Now, type out on the terminal the following:
\begin{lstlisting}[language=bash]
   [user@machine ~]$ ls
\end{lstlisting}
The expected output, is a listing of all files and folders available
\textbf{directly} on the current work directory (I said it was important). Done,
you executed your first bash command! The majority of commands supports what we
call \textbf{arguments}, that can be present in different forms, like
\textbf{flags}, \textbf{parameters} and \textbf{positional}. Let's try it out:
\begin{lstlisting}[language=bash]
   [user@machine ~]$ ls -a
\end{lstlisting}
\begin{definitionbox}
    \begin{description}
        \item[Argument:] A value, whose format can vary, that informs something
            to the program that will be executed. In this way, he allows more
            interaction and control of the user with the command itself.
        \item[Flag:] A flag consists in an argument that doesn't have a value.
            It usually appears in the format of a single dash followed by a letter
            (-l, -a, etc).
        \item[Parameter:] A parameter is an argument with an user determined
            value. The base format of a parameter is two dashes followed by
            a space and the value (like in -{}-help). In some cases, the space
            is substituted for a equality symbol (like in -{}-output=/home). 
        \item[Positional argument:] Indicates to the command which directory or
            file it should  seek and operate. Usually presents itself with
            a space from the rest of the arguments and the initial command
            followed by the path to needed directory or file.
    \end{description}
\end{definitionbox}
Now, you can see a lot more files are being shown. That's because the
\textbf{-a} flag indicates to the command that you want to see \textbf{all}
possible files and directories under the current work directory. So, now your
output will also include the hidden files, marked by the presence of a single
dot before the file name.\par
\begin{remarkbox}
In the majority of commands or terminal executed scripts, you can see a summary
of possible flags and operational directions for command usage applying the
-{}-help parameter or the -h flag.
\end{remarkbox}
\begin{tipbox}
    For better quality of life, you can use the up and down arrow keys to
    access the \textbf{terminal command history}. Try cycling through previous
    commands and re-running them.
\end{tipbox}
This covers up our initial contact with the shell and terminal. As a way of
saying goodbye, instead of closing the window in the traditional way, you can
exit the shell by simply typing the below!
\begin{lstlisting}[language=bash]
   [user@machine ~]$ exit 
\end{lstlisting}
\subsubsection{The file system tree}
Now, we are going to approach the file system tree of Linux based systems. The
tree analogy says it all, the files are organized in what's called
\textbf{hierarchical directory structure}(\cite{shottsLinuxCommandLine2024}). In
this sense, the system has a base for the tree, which we call the \textbf{root
directory}. All others directories, that we can think as branches, and files,
the leaves,  will be located inside this root.
\begin{remarkbox}
    Unix-like systems approach storage devices in a particular way. They're
    treated as part of the single file system tree that begins on the root. That
    being, any storage device that is connected to the system, is being
    \textbf{mounted} in certain \textbf{point}(location) inside the main tree.
\end{remarkbox}
Below you can see some of the root base sub-directories
(\cite{garrelsIntroductionLinux2008}).
\begin{definitionbox}
    \begin{description}
        \item [bin:] Programs shared by the system, the system administrator and
            all of the users.
        \item [boot:] Stores the startup files and the kernel.
        \item [etc:] Stores the most important system configuration files.
        \item [home:] Acts as a "root" for the directories of common system 
            users.
        \item [lib:] Library files needed by the system and it's users.
        \item [mnt:] Standard mount point for all external file systems.
        \item [root:] The home directory of the system administrator.
        \item [tmp:] Used to store temporary files, being cleaned up on reboot.
        \item [usr:] Files and directories related to all user-related programs.
    \end{description}
\end{definitionbox}
\begin{remarkbox}
    \textbf{Caution!} The /root refers to the administrator home directory,
    while / refers to the root directory.
\end{remarkbox}
\subsubsection{Navigating with the shell}
Remember when was said that the current work directory is important? Now's the
time to understand why. As was presented on the previous sub-section, Linux based
systems operate on a single rooted file system. This implies that we can, from 
inside the terminal, access all existent sub-directories and files, but also,
that a hierarchical order is present. In this sense, we can conclude that the
terminal needs to know where he stands on this tree to operate in the intended
way.\par
When opening a new terminal window, we saw that after the machine name, the
\textbf{current working directory} is shown. This is where the terminal
stands on the tree. The logic of this is easier comprehended by
imagining as if we are at the CWD looking forward. We can see all connected
branches and the current branch leaves and operate on them and theirs
subsequent branches and leaves. We saw this with the ls command previously
tested. \par
Let's try some basic terminal navigation. Open a new terminal window (Ctrl+Alt+T on
Linux Mint). Let's check the current work directory we are on:

\begin{lstlisting}[language=bash]
   [user@machine ~]$ pwd
\end{lstlisting}
\begin{remarkbox}
    The \textasciitilde {} directory is a short way to refer to the current
    user home directory. It's the equivalent of /home/user/. You can test this
    by opening a terminal window and typing the \textbf{pwd} command, that shows
    the name of the current WD.
\end{remarkbox}
If all worked as supposed to, the current WD was shown on the screen. Great!
Now, let's create a test directory inside the current one and make it our new
WD. After that, let's run again the pwd command.
\begin{lstlisting}[language=bash]
   mkdir test
   cd test
   pwd
\end{lstlisting}
First, we used \textbf{mkdir} with the argument 'test' to create a new
sub-directory called test. Then, the \textbf{cd} command allowed us to change
our WD to the one specified as an argument, in this case 'test'. The output of
\textbf{pwd} shows that we did, indeed, change the current "point of view" of
our shell session.\par
Still in this terminal, try to change again to the test folder. As you can see,
the bash returns a message saying that he wasn't able to find such file or
directory. This is because it really doesn't exists! At least not inside the WD.
Remember, the Linux file system is hierarchical. In this sense, the command
searches and operates based on the current work directory, seeing only the
branches and leaves that are "inside" of it. This is extremely relevant, for
when running scripts or other commands from a terminal, we need to make sure the
correct WD is set, because other way, the shell call won't be able to find and
operate on the intended files and directories.
\begin{tipbox}
    The cd usage can be simplified in some cases. If we want to go back to the
    user home directory, we can use:
\begin{lstlisting}[language=bash]
  cd ~ 
\end{lstlisting}
    Also, the parent folder can be referred as two dots (..). Using this we can:
\begin{lstlisting}[language=bash]
   cd .. # goes up one parent folder
   cd ../.. # goes up two parent folders, and so on 
\end{lstlisting}
\end{tipbox}
\begin{remarkbox}
    Linux based systems have what is called a \textbf{PATH environment
    variable}. This consists on a system variable that can be changed if
    necessary that contains a list of system paths. Anytime a shell session
    begins and any command is executed, the system searches not only the  WD
    and it's sub-directories and files, but also the paths included in this
    environment variable.
\end{remarkbox}
\subsubsection{Commands}
Aiming to provide some base commands, the user can see the cheat sheet below. In
depth command usage, availability and functionality can be found on software or
distribution documentation.
\begin{cheatsheetbox}
\textbf{Command:} \texttt{ls} \\
\textbf{Description:} List files in current work directory.
\noindent\makebox[\linewidth]{\dotfill}
\textbf{Command:} \texttt{pwd} \\
\textbf{Description:} List current work directory.
\noindent\makebox[\linewidth]{\dotfill}
\textbf{Command:} \texttt{cd 'new-directory'} \\
\textbf{Description:} Changes current work directory.
\noindent\makebox[\linewidth]{\dotfill}
\textbf{Command:} \texttt{mkdir 'new-directory'} \\
\textbf{Description:} Creates new directory inside current WD or on given path.
\noindent\makebox[\linewidth]{\dotfill}
\textbf{Command:} \texttt{cp 'file' 'copy-location'} \\
\textbf{Description:} Creates a copy of certain files inside the given 
location.
\noindent\makebox[\linewidth]{\dotfill}
\textbf{Command:} \texttt{mv 'current-location' 'new-location'} \\
\textbf{Description:} Moves a file inside the file system.
\noindent\makebox[\linewidth]{\dotfill}
\textbf{Command:} \texttt{df} \\
\textbf{Description:} Show current amount of free space on the disk drives.
\noindent\makebox[\linewidth]{\dotfill}
\textbf{Command:} \texttt{lsblk} \\
\textbf{Description:} Show current mounted disks and their mount points.
\noindent\makebox[\linewidth]{\dotfill}
\textbf{Command:} \texttt{rm 'file-path'} \\
\textbf{Description:} Removes the file indicated.
\end{cheatsheetbox}

\section{Git}

\section{Conda}

\section{}


\section{Tools \& Software}

\subsection{Required Software}
\sn{Installation notes}

\begin{itemize}
    \item \textbf{Primary tool:} Tool name and version
    \item \textbf{Dependencies:} Required libraries/packages
    \item \textbf{Optional:} Additional helpful tools
\end{itemize}

\subsection{Installation Guide}
\begin{lstlisting}[language=bash, caption=Software installation]
# Installation commands
conda install -c bioconda tool_name
# or
sudo apt-get install package_name
\end{lstlisting}

\section{Workflow \& Methods}

\subsection{Step-by-Step Protocol}
\sn{Key parameters}

\begin{enumerate}
    \item \textbf{Data preparation:} Input requirements and formatting
    \item \textbf{Quality control:} Initial data assessment
    \item \textbf{Main analysis:} Core computational steps
    \item \textbf{Result interpretation:} Output analysis and validation
\end{enumerate}

\begin{example}
Practical example with real genomic data.
\end{example}

\section{Practical Examples}

\subsection{Example 1: Basic Analysis}
\sn{Input/output files}

\begin{itemize}
    \item \textbf{Input:} Sample data description
    \item \textbf{Command:} Based on approach from \cite{example2024}
    \item \textbf{Output:} Expected results and file formats
\end{itemize}

\begin{lstlisting}[language=bash, caption=Basic command example]
# Example command with typical genomic data
tool_name -i input_file.fasta -o output_file.txt --parameter value
\end{lstlisting}

\subsection{Example 2: Advanced Usage}
\sn{Complex parameters}

\begin{lstlisting}[language=bash, caption=Advanced analysis pipeline]
# Multi-step analysis pipeline
step1_tool input.fasta | step2_tool --param1 value1 > intermediate.txt
step3_tool intermediate.txt --param2 value2 -o final_result.txt
\end{lstlisting}

\section{Results \& Interpretation}

\subsection{Output Files}
\sn{File formats}

Common output formats and their interpretation:
\begin{itemize}
    \item \textbf{Format 1:} Description and typical contents
    \item \textbf{Format 2:} When and how to use this output
    \item \textbf{Quality metrics:} How to assess result quality
\end{itemize}

\begin{remark}
Important note about result interpretation following \citet{author2024}.
\end{remark}

\section{Scripts \& Code}

\subsection{Helper Scripts}
\begin{lstlisting}[language=Python, caption=Data processing script]
#!/usr/bin/env python3
"""
Helper script for genomic data processing
Usage: python script.py input.fasta output.txt
"""

def process_sequences(input_file, output_file):
    """Process genomic sequences"""
    with open(input_file, 'r') as f:
        sequences = f.read()
    
    # Processing logic here
    processed = sequences.upper()
    
    with open(output_file, 'w') as f:
        f.write(processed)

if __name__ == "__main__":
    import sys
    process_sequences(sys.argv[1], sys.argv[2])
\end{lstlisting}

\subsection{Quality Control}
\begin{lstlisting}[language=bash, caption=QC pipeline]
#!/bin/bash
# Quality control pipeline for genomic data

# Check file format
file_format_check.py $INPUT_FILE

# Basic statistics
sequence_stats.py $INPUT_FILE > stats.txt

# Quality assessment
quality_assessment_tool $INPUT_FILE --output qc_report.html
\end{lstlisting}

\section{Troubleshooting \& Best Practices}

\subsection{Common Issues}
\sn{Error solutions}

\begin{itemize}
    \item \textbf{Memory errors:} Reduce dataset size or increase available RAM
    \item \textbf{Format issues:} Check input file formatting and encoding
    \item \textbf{Parameter tuning:} Guidelines for optimization
\end{itemize}

\subsection{Best Practices}
\begin{itemize}
    \item \textbf{Data backup:} Always keep original data copies
    \item \textbf{Version control:} Track analysis versions and parameters
    \item \textbf{Documentation:} Record all analysis steps and decisions
    \item \textbf{Reproducibility:} Use consistent environments and seeds
\end{itemize}

\begin{references}
    \item Key papers: \cite{example2024,author2024,smith2024}
    \item Software documentation: [Tool official docs]
    \item Related modules: [Other workflow modules]
\end{references}

\section{Exercises \& Next Steps}

\begin{itemize}
    \item \todo{Practice with provided sample data}
    \item \todo{Try different parameter settings}
    \item \important{Apply to your own genomic dataset}
    \item \todo{Explore advanced features}
\end{itemize}

\begin{notes}
Additional observations and module-specific notes...

\highlight{Key insight}: Connection between this tool and genome annotation pipeline

\idea{Extension}: Integration with other bioinformatics tools in the workflow

\end{notes}

% BIBLIOGRAPHY
\newpage
\printbibliography

\end{document}
