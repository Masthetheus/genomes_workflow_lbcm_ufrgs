% Genomes Workflow Module Template - LBCM UFRGS
% Based on NotesTeX and Gilles Castel's aesthetic approach
% Module: 01 - General guidelines and workflow organization
% Date: DATE_PLACEHOLDER

\documentclass[a4paper,11pt]{article}

% Use ONLY the beautiful notes preamble for notes
\input{preamble.tex}

\title{
    \vfill
    \textcolor{noteblue}{\Huge Genomes Workflow - LBCM}\\
    \vspace{5.0cm}
    \textcolor{sidenotegray}{\huge 01 - General guidelines and workflow organization}\\
    \vspace{1.5cm}
    \textcolor{sidenotegray}{\LARGE }\\
    \vspace{5.0cm}
    \textcolor{sidenotegray}{\large \today}
    \vfill
}
\author{}
\date{}

\begin{document}

\maketitle
\thispagestyle{empty}
\newpage
\tableofcontents
\newpage
\section{Overview}

\subsection{Module Objectives}
\sn{Learning goals}

This module covers:
\begin{itemize}
    \item Basic Linux terminal concepts and usage.
    \item What is git and basic usage.
    \item Conda environment logic.
    \item Conda basic usage.
    \item Recommended bioinformatics project organization.
\end{itemize}

\section{The Linux question}
Taking in consideration the variety of tools available, their functionalities
and general comprehension around systems and workflow organization, the choice
of operational system constitutes a central point. \par 
In multiple fronts, Linux get's the spotlight. One big advantage is the cost to
install and implement the OS: Zero. With a GPL License, everyone has the right
to change and redistribute it, following the condition that the code should stay
available (\cite{garrelsIntroductionLinux2008}). It's portability, security and
the existence of a large and committed community all helps on the final OS
choice for general Bioinformatics research projects.\par
In the current chapter, we intend to present basics concepts of the Linux
ecosystem. Terminal operation will also be included, since it's intrinsic
relation to the system core functionalities. Finally, a brief Linux Mint
presentation and guidelines shall be pointed, as it's the initial distro of
choice.\par
\begin{remarkbox}
    For further and in depth comprehension of base Linux related topics, it is
    advised to check \cite{garrelsIntroductionLinux2008}.
\end{remarkbox}
\subsection{So... What is it?}
With the crescent wave on tech development, the fact that some systems were
directly developed for specific hardware started to weight a ton on user
instruction and final cost of the products. A team of developers then started
working on what would come to be the \textbf{"UNIX"} project. This operational system
brought to the table the ability of code to be recycled, the use of
a higher programming language then assembly (C) and an unique overall
simplicity (\cite{garrelsIntroductionLinux2008}).\par
\begin{definitionbox}
   UNIX refers to a family of operational systems based on the final product of
   the original UNIX project. They aim to be simple, elegant and allow code
   recycling. To achieve their goals, modular logic is applied, alongside
   a hierarchical file system and innate command line interface. 
\end{definitionbox}
Then, home PC's started getting traction, in a way that running UNIX on them
became a possibility. In this context, the idea of a free system directly
connected to the original \textbf{UNIX} would led to the birth of \textbf{Linux}
as a freely available OS.
\begin{definitionbox}
    Linux is an open source OS based on UNIX. Is composed mainly by
    (\cite{WhatLinux2025}):
    \begin{description}
        \item[Bootloader:] Manages the boot process of the computer.
        \item[Kernel:] The actual \textbf{Linux}. Manages the CPU, memory and
            peripheral devices.
        \item[Initialization system:] Sub-system that controls daemons.
        \item[Daemons:] Background services started up during or after boot.
        \item[Graphical server:] Sub-system for graphical display.
        \item[Desktop environment:] Interfaces for direct user interaction.
        \item[Applications:] Any software that can be installed on the system
            and offer some service or act as a tool.
    \end{description}
\end{definitionbox}
\subsection{Choosing a Distro}
A lifelong debates inside the Linux community revolves around which  Linux
distribution to choose. One of the biggest reasons for such is that there's no
correct answer. Multiple factors interfere in the final choice, and it can be
largely personal too.\par
Across the internet, a variety of guides and lists can be found on the subject.
As it's not the central purpose of this project, we won't dive deeply in this
matter. But, even though this creative freedom was taken, we will still, in
a further chapter, approach one specific Linux distro, called Linux Mint. This
decision was made to lay a foundation for some installation instructions, that
can change based on the system of choice. Always when that's the case, it shall
be pointed out.\par
The choice of Mint itself was based purely on the fact that it is a distro with
large support, reach and with a more reasonable learning curve for Linux
newcomers.

\begin{tipbox}
    If you want to dive a little deeper on the Mint Distro, we recommend it's
    User Guide (\cite{mintUserGuideLinux2024}). In it, you can find informations
    on the system's update manager, multiboot, upgrades from older versions and
    so on. The online official documentation Linux Mint webpage presents in
    multiple format all available guides (\cite{mintLinuxMintDocumentation2025}). 
\end{tipbox}

\subsection{Installing The Chosen One}
An encouraged practice when making a software available is to always provide
an in depth documentation on it. One can assume, then, that almost every, if not
all, chosen Linux distribution has a guide to system installation and usage.
Taking this in mind, the current project will describe in general lines the
basic needs to install a distro, with some key concepts and necessary tools,
avoiding redundancy with the material the system itself has.
\subsubsection{Before anything...}
When faced with the idea to change the current OS to a Linux distro, before
major definitive modifications are made, some safety measures are encouraged.
The central point is to make sure that everything runs smoothly, and avoid
system breaking errors and data loss as much as possible. In this project, we
joined some general measures, presented below.

\begin{description}
\item[Applications list:] The majority of bioinformatics software is designed
    with Linux based systems in mind, or provides a compatible version. But,
    it's recommended to make a list of the main needs and goals of the operator
    with the system to facilitate the post-install and prevent incompatibility
    issues.
\begin{tipbox}
This list can also be used to help in choosing the distro that fits your needs
the best.
\end{tipbox}
\item[Backup:] Always backup crucial files.
\item[Driver support:] It's a good practice to check also if external drivers of
    daily and necessary use have functional drivers for Linux based systems.
\item[System requirements:] Check beforehand if your current hardware
    specifications match at least the minimum requirements of the chosen distro.
    Usually this information can be found in the main webpage of the OS.
\item[Tool and Applications support:] Although a lot of software nowadays is
    developed with Linux compatibility in mind, that's not always the case. Some
    services like the Microsoft Office Package and the Adobe Suite don't have
    a secure and optimal distribution for Linux based systems, making their
    usage impossible, impractical or unreliable.
\end{description}
After considering the items listed above, you can better decide which path to
take.
\begin{tipbox}
If you aren't yet secure of moving totally to Linux, you can set up a Dual Boot
function with your current OS and your distro of choice. You can also use
a Virtual Machine to emulate a Linux environment and use the OS from inside it!
\end{tipbox}
\subsubsection{Tools}
In the majority of cases, not much is needed to proceed with a Linux OS
installation. Usually, it sums up to:
\begin{description}
    \item [Bootable device:] A storage medium containing the core files for the
        installation of the chosen distro. Usually consists on the medium with
        the chosen system's ISO file "flashed" into.
    \item [Image writer:] A dedicated software that is able to correctly flash
        a storage device with an system image, turning it into a bootable
        device.
    \item [ISO file:] Is a file on the ISO format that contains the necessary
        structure, directions and files for the correct system installation.
\end{description}
\begin{definitionbox}
    \textbf{Flashing:} Consists on taking an ISO image and transferring all the
    partitions, file systems and files that were present on the device used to
    create the image.\par 
    \textbf{ISO format:} The ISO format can be seen as the equivalent of replicating
        the contents and structure of a CD, DVD or even a Blu-Ray disc.\par 
        \textbf{Storage device:} An external drive that can be used as a storage
        medium, e.g. an USB flash drive.  
\end{definitionbox}
\subsubsection{Validating the ISO}
As we can infer, given the above definitions, the process basically consists on
taking the target OS general structure and files, flashing it into the bootable
device and using the latter to build the system on the machine. Thus, we can
logically infer, the success of the operation relies heavily on the integrity of
the ISO file, as it represents what will be installed.\par
To avoid the task of manually reviewing, we have more automated means to check
integrity. For that, in the majority of cases, we can use SHA256 sums to
complete this task. The usual workflow for such is:
\begin{enumerate}
    \item Download the correct sha256sum.txt and sha256sum.txt.gpg files
        according to the chosen distro and version.\par
        \textbf{Obs:} Make sure to download the files themselves, and not just
        copy and paste their content on a new file.
    \item Open a terminal window where the downloaded sha256sum.txt file is, or
        navigate to the location.
    \item If on a Linux system, verify the \textbf{integrity} with:
\begin{lstlisting}[language=bash]
sha256sum -b chosendistro.iso
# Or, if the iso is on another location
sha256sum -b /path/to/chosendistro.iso
\end{lstlisting}
    \begin{remarkbox}
        On macOS, the command structure is similar, although the command itself
        is only \textbf{shasum}. But, if you are currently using Windows, the
        process follows a distinct path. If that's the case, we recommend
        checking the guide available on the
        \href{https://forums.linuxmint.com/viewtopic.php?f=42&t=291093}{Linux
        Mint Forum}, that approaches the problem at hand. 
    \end{remarkbox}
    \item If both match, the ISO image was successfully downloaded. If not, it's
        advisable to re-download the file.
        \begin{tipbox}
            Before downloading the ISO again, it's always worth the shot to
            check a second time if the correct hash file is being tested, that
            being, the hash for the same distro and same distro version chosen.
        \end{tipbox}
\end{enumerate}
\begin{remarkbox}
    The shum files are usually provided with the ISO download or can be
    retrieved in the same page as the main download mirror.\par
    If you wish to further comprehend what the SHA hash is and how it allows
    data verification, we recommend the quick post available at
    \href{https://www.howtogeek.com/67241/htg-explains-what-are-md5-sha-1-hashes-and-how-do-i-check-them/}{How
    to Geek.}
   
\end{remarkbox}
Okay, the file is intact. But, how do we know that the hash file used to test
it's integrity is really authentic, and wasn't corrupted or altered? Simple,
checking it's authenticity. In the case of Linux Mint, it goes as follow
(\cite{mintInstallationGuide2024}):
\begin{enumerate}
    \item Import the Linux Mint signing key.
        \begin{lstlisting}[language=bash]
gpg --keyserver hkp://keys.openpgp.org:80 --recv-key \
27DEB15644C6B3CF3BD7D291300F846BA25BAE09    
\end{lstlisting}
    \item Check key importation:
\begin{lstlisting}[language=bash]
gpg --list-key --with-fingerprint A25BAE09\end{lstlisting}
    \item Confirm that the output from the previous command presents the key
        informed on the first command used and the relation to Linux Mint.
    \item Check the authenticity with:
\begin{lstlisting}[language=bash]
gpg --verify sha256sum.txt.gpg sha256sum.txt
\end{lstlisting}
    \item If the output points that the signature is good and was made with the
        key imported, the test was passed.
\end{enumerate}
\begin{tipbox}
\begin{description}
\item[PATH:] Make sure that all files informed on the commands are on the
    current work directory of the opened terminal. If not, you can either change
    the terminal WD, the files location or specify the full path to the files on
    the commands.
\item[GPG warning:] The GPG may send a warn that the signature isn't trusted by
    the computer, this is expected and normal. 
\end{description}
\end{tipbox}
\subsubsection{Process Overview}
A full installation guide can usually be found on your distro of choice
homepage. It usually covers all the needed steps and present FAQ's to help with
following them.
\href{https://linuxmint-installation-guide.readthedocs.io/en/latest/}{Here} 
you can see the documentation for installing Linux Mint.
The process has similar features for all distros:
\begin{enumerate}
    \item Choose and download the intended version.
    \item Verify the ISO integrity.
    \item Create the bootable device.
    \item Insert the bootable media onto your machine and boot from it (Usually
        accessing the BIOS and changing boot order).
    \item Enter the system.
    \item Start the installation setup and follow the steps pointed.
    \item Reboot the machine.
    \item Remove the bootable device.
\end{enumerate}
The new OS is almost completely ready to use!
\begin{tipbox}
Most Linux distributions allow the user to test the system before fully
installing via the bootable device.
\end{tipbox}
\subsubsection{Aftermath}
With the installation done, the core of the system is available for you to use.
But, some actions are recommended.
\begin{description}
\item[Extra drivers:] After the first package repository update, check and
    install possible needed drivers. This step ensures good functioning of
    connected devices and machine hardware. The
    \href{https://linuxmint-installation-guide.readthedocs.io/en/latest/drivers.html}{Linux
    Mint Documentation} offers a step-by-step guide for this task.
\item[Language and Keyboard Layout:] Usually set during installation, but
    sometimes the user may need to add support to other languages and layouts or
    change the previously selected. For Linux Mint this can be done on the
    Languages or Keyboard layout settings.
\item[Multimedia codecs:] Some media functionalities require specific codecs that
    may not come with the installed version, even if the option is given during
    installation. If that's the case, they must be manually installed, according
    to the user's need and current distro. The
    \href{https://linuxmint-installation-guide.readthedocs.io/en/latest/codecs.html}{Linux
    Mint Documentation} also approach this subject.
    \item[Update the system:] Although the base applications, drivers, libraries
        and others are already installed, it's a good habit to update them after
        the first reboot and from time to time. Some distributions, like Mint
        and Ubuntu, offer a GUI application to do so, but all distributions
        offer a terminal package manager option. For Debian derived distros,
        like Mint, one can achieve this by running on the terminal the
        following:
\begin{lstlisting}[language=bash]
# Refresh package list
sudo apt update
# Install all available updates
# for installed packages
sudo apt upgrade
\end{lstlisting}
\begin{tipbox}
It's a good practice to check which packages are available to upgrade, since the
operation may cause versioning problems.
\end{tipbox}
\end{description}
\subsection{Command Line and Terminal operation}
When using Linux based OS's, one specific "feature" get's the spotlight on the
eyes of newcomers: the command line. Basically all tasks done via GUI's can be
also executed via command line, usually mediated with a terminal interface.\par
Taking this in mind, understanding the relevance and basic navigation of the
command line, allows an overall better and more efficient system operation. In
this sense, the present section aims to establish broad concepts and present
general guidelines on the subject.
\begin{definitionbox}
    The term command line, actually refers to the \textbf{shell}. It consists in
    a program whose purpose is to take keyboard commands and direct them to the
    OS for execution. In Linux systems, the core \textbf{shell} usually is
    \textbf{bash}. \textbf{Terminals} are interfaces that allow users with a GUI to
    interact with the \textbf{shell}(\cite{shottsLinuxCommandLine2024}).
\end{definitionbox}
\subsubsection{Basics}
Nothing better to learn than getting punched by the subject. Let's experiment
with basic terminal manipulation and usage. This section is an adaptation of the
first chapter of \cite{shotssLinuxCommandLine2024}, in that sense, for further
comprehension on the subject, please refer to the main source.\par
First, open the terminal window (Ctrl+Alt+T on Linux Mint). What you are now
seeing, I hope so, is something like:
\begin{lstlisting}[language=bash]
   [user@machine ~]$ 
\end{lstlisting}
Or, if using conda, probably something like:
\begin{lstlisting}[language=bash]
   (base)[user@machine ~]$ 
\end{lstlisting}
This is what we call the shell prompt, indicating that it's ready to receive
orders. It informs you the current user name, the machine name and the current
directory. Knowledge of the directory currently set is of extreme importance,
and will be discussed on the next topic.\par
Now, type out on the terminal the following:
\begin{lstlisting}[language=bash]
   [user@machine ~]$ ls
\end{lstlisting}
The expected output, is a listing of all files and folders available
\textbf{directly} on the current work directory (I said it was important). Done,
you executed your first bash command! The majority of commands supports what we
call \textbf{arguments}, that can be present in different forms, like
\textbf{flags}, \textbf{parameters} and \textbf{positional}. Let's try it out:
\begin{lstlisting}[language=bash]
   [user@machine ~]$ ls -a
\end{lstlisting}
\begin{definitionbox}
    \begin{description}
        \item[Argument:] A value, whose format can vary, that informs something
            to the program that will be executed. In this way, he allows more
            interaction and control of the user with the command itself.
        \item[Flag:] A flag consists in an argument that doesn't have a value.
            It usually appears in the format of a single dash followed by a letter
            (-l, -a, etc).
        \item[Parameter:] A parameter is an argument with an user determined
            value. The base format of a parameter is two dashes followed by
            a space and the value (like in -{}-help). In some cases, the space
            is substituted for a equality symbol (like in -{}-output=/home). 
        \item[Positional argument:] Indicates to the command which directory or
            file it should  seek and operate. Usually presents itself with
            a space from the rest of the arguments and the initial command
            followed by the path to needed directory or file.
    \end{description}
\end{definitionbox}
Now, you can see a lot more files are being shown. That's because the
\textbf{-a} flag indicates to the command that you want to see \textbf{all}
possible files and directories under the current work directory. So, now your
output will also include the hidden files, marked by the presence of a single
dot before the file name.\par
\begin{remarkbox}
In the majority of commands or terminal executed scripts, you can see a summary
of possible flags and operational directions for command usage applying the
-{}-help parameter or the -h flag.
\end{remarkbox}
\begin{tipbox}
    For better quality of life, you can use the up and down arrow keys to
    access the \textbf{terminal command history}. Try cycling through previous
    commands and re-running them.
\end{tipbox}
This covers up our initial contact with the shell and terminal. As a way of
saying goodbye, instead of closing the window in the traditional way, you can
exit the shell by simply typing the below!
\begin{lstlisting}[language=bash]
   [user@machine ~]$ exit 
\end{lstlisting}
\subsubsection{The file system tree}
Now, we are going to approach the file system tree of Linux based systems. The
tree analogy says it all, the files are organized in what's called
\textbf{hierarchical directory structure}(\cite{shottsLinuxCommandLine2024}). In
this sense, the system has a base for the tree, which we call the \textbf{root
directory}. All others directories, that we can think as branches, and files,
the leaves,  will be located inside this root.
\begin{remarkbox}
    Unix-like systems approach storage devices in a particular way. They're
    treated as part of the single file system tree that begins on the root. That
    being, any storage device that is connected to the system, is being
    \textbf{mounted} in certain \textbf{point}(location) inside the main tree.
\end{remarkbox}
Below you can see some of the root base sub-directories
(\cite{garrelsIntroductionLinux2008}).
\begin{definitionbox}
    \begin{description}
        \item [bin:] Programs shared by the system, the system administrator and
            all of the users.
        \item [boot:] Stores the startup files and the kernel.
        \item [etc:] Stores the most important system configuration files.
        \item [home:] Acts as a "root" for the directories of common system 
            users.
        \item [lib:] Library files needed by the system and it's users.
        \item [mnt:] Standard mount point for all external file systems.
        \item [root:] The home directory of the system administrator.
        \item [tmp:] Used to store temporary files, being cleaned up on reboot.
        \item [usr:] Files and directories related to all user-related programs.
    \end{description}
\end{definitionbox}
\begin{remarkbox}
    \textbf{Caution!} The /root refers to the administrator home directory,
    while / refers to the root directory.
\end{remarkbox}
\subsubsection{Navigating with the shell}
Remember when was said that the current work directory is important? Now's the
time to understand why. As was presented on the previous sub-section, Linux based
systems operate on a single rooted file system. This implies that we can, from 
inside the terminal, access all existent sub-directories and files, but also,
that a hierarchical order is present. In this sense, we can conclude that the
terminal needs to know where he stands on this tree to operate in the intended
way.\par
When opening a new terminal window, we saw that after the machine name, the
\textbf{current working directory} is shown. This is where the terminal
stands on the tree. The logic of this is easier comprehended by
imagining as if we are at the CWD looking forward. We can see all connected
branches and the current branch leaves and operate on them and theirs
subsequent branches and leaves. We saw this with the ls command previously
tested. \par
Let's try some basic terminal navigation. Open a new terminal window (Ctrl+Alt+T on
Linux Mint). Let's check the current work directory we are on:

\begin{lstlisting}[language=bash]
   [user@machine ~]$ pwd
\end{lstlisting}
\begin{remarkbox}
    The \textasciitilde {} directory is a short way to refer to the current
    user home directory. It's the equivalent of /home/user/. You can test this
    by opening a terminal window and typing the \textbf{pwd} command, that shows
    the name of the current WD.
\end{remarkbox}
If all worked as supposed to, the current WD was shown on the screen. Great!
Now, let's create a test directory inside the current one and make it our new
WD. After that, let's run again the pwd command.
\begin{lstlisting}[language=bash]
   mkdir test
   cd test
   pwd
\end{lstlisting}
First, we used \textbf{mkdir} with the argument 'test' to create a new
sub-directory called test. Then, the \textbf{cd} command allowed us to change
our WD to the one specified as an argument, in this case 'test'. The output of
\textbf{pwd} shows that we did, indeed, change the current "point of view" of
our shell session.\par
Still in this terminal, try to change again to the test folder. As you can see,
the bash returns a message saying that he wasn't able to find such file or
directory. This is because it really doesn't exists! At least not inside the WD.
Remember, the Linux file system is hierarchical. In this sense, the command
searches and operates based on the current work directory, seeing only the
branches and leaves that are "inside" of it. This is extremely relevant, for
when running scripts or other commands from a terminal, we need to make sure the
correct WD is set, because other way, the shell call won't be able to find and
operate on the intended files and directories.
\begin{tipbox}
    The cd usage can be simplified in some cases. If we want to go back to the
    user home directory, we can use:
\begin{lstlisting}[language=bash]
  cd ~ 
\end{lstlisting}
    Also, the parent folder can be referred as two dots (..). Using this we can:
\begin{lstlisting}[language=bash]
   cd .. # goes up one parent folder
   cd ../.. # goes up two parent folders, and so on 
\end{lstlisting}
\end{tipbox}
\begin{remarkbox}
    Linux based systems have what is called a \textbf{PATH environment
    variable}. This consists on a system variable that can be changed if
    necessary that contains a list of system paths. Anytime a shell session
    begins and any command is executed, the system searches not only the  WD
    and it's sub-directories and files, but also the paths included in this
    environment variable.
\end{remarkbox}
\subsubsection{Commands}
Aiming to provide some base commands, the user can see the cheat sheet below. In
depth command usage, availability and functionality can be found on software or
distribution documentation.
\begin{cheatsheetbox}
\textbf{Command:} \texttt{ls} \\
\textbf{Description:} List files in current work directory.
\noindent\makebox[\linewidth]{\dotfill}
\textbf{Command:} \texttt{pwd} \\
\textbf{Description:} List current work directory.
\noindent\makebox[\linewidth]{\dotfill}
\textbf{Command:} \texttt{cd 'new-directory'} \\
\textbf{Description:} Changes current work directory.
\noindent\makebox[\linewidth]{\dotfill}
\textbf{Command:} \texttt{mkdir 'new-directory'} \\
\textbf{Description:} Creates new directory inside current WD or on given path.
\noindent\makebox[\linewidth]{\dotfill}
\textbf{Command:} \texttt{cp 'file' 'copy-location'} \\
\textbf{Description:} Creates a copy of certain files inside the given 
location.
\noindent\makebox[\linewidth]{\dotfill}
\textbf{Command:} \texttt{mv 'current-location' 'new-location'} \\
\textbf{Description:} Moves a file inside the file system.
\noindent\makebox[\linewidth]{\dotfill}
\textbf{Command:} \texttt{df} \\
\textbf{Description:} Show current amount of free space on the disk drives.
\noindent\makebox[\linewidth]{\dotfill}
\textbf{Command:} \texttt{lsblk} \\
\textbf{Description:} Show current mounted disks and their mount points.
\noindent\makebox[\linewidth]{\dotfill}
\textbf{Command:} \texttt{rm 'file-path'} \\
\textbf{Description:} Removes the file indicated.
\end{cheatsheetbox}

\section{Git}
Git is a powerful tool for handling different aspects of projects related to
their development, maintenance and distribution. Based on this, we consider that
approaching some basic concepts and presenting useful commands should be helpful
for newcomers in the bioinformatics field.
\subsection{What is it?}
Git is a Version Control System that conceptualizes the data that's stored as
a series of snapshots of a mini file system. So, by using the command to commit
the changes, git takes a snapshot of the current state of the files and stores
a reference to it (\cite{straubProGit2025}). The capability of simultaneous work
on the same file system in a controlled environment, with a large and
lightweight support of branch creation, is what makes git an important tool to
learn.\par
\begin{definitionbox}
    \textbf{Branches} are a core functionality of nearly every VCS. It consists
    on diverging from a main state of the current project and being able to work
    on it without directly affecting the origin (\cite{straubProGit2025}).
    So, if all go wrong,
    you can just go back in time. And, if all goes right, you merge. Neat.
\end{definitionbox}
The user initially clones an available repository, thus receiving all of it's
files and file structure. Then, he can operate locally on them and commit
eventual changes, that can be reviewed, if necessary, and merged with the 
original source.
\subsection{The basics}
Let's work on a hipotetical example, aiming to exercise git basic operation.
Firstly, we must be sure git is installed on the current system. In a new
terminal, run the following:
\begin{lstlisting}[language=bash]
git --help
\end{lstlisting}
If further instructions on git usage are shown, then git is installed and can be
used for repository manipulation on the current machine. 
\begin{tipbox}
On Linux Mint, you can install git via:
\begin{lstlisting}[language=bash]
sudo apt update # refresh the package listing
sudo apt install git #install the git package
\end{lstlisting}
Also, if it's the user's first time on git, we recommend checking
\href{https://git-scm.com/book/en/v2/Getting-Started-First-Time-Git-Setup}{git's
first time setup docs.} 
\end{tipbox}
Ok, now we are going to fetch the current repository and start to work within
it.
\begin{lstlisting}[language=bash]
git clone https://github.com/user/repository_name.git
cd repository_name
ls -a # Here you can see that all files
      # and repository structure are now
      # downloaded and available locally
\end{lstlisting}
Inside the new folder system gathered, you can start manipulating files and
structure. But, first, it's usually recommended to create a new branch for such,
aiming to maintain system integrity and organization. Further information on git
branching can be seen on the \href{https://git-scm.com/docs/git-branch}{git
doc's.} 
\begin{lstlisting}[language=bash]
git branch --list # shows currently available branches
git checkout -b new_branch_name # creates new branch and switches
                                # automatically to it 
\end{lstlisting}
\begin{tipbox}
You can see where you are in comparison with the bigger picture with the command
below. It shows your current branch, it's relation to the origin and your
current work "status".
\begin{lstlisting}[language=bash]
git status
\end{lstlisting}
\end{tipbox}
Let's suppose you made some changes and want to sync them with the non-local
repository. Firstly, you need to stage the changes. This means that you need to
inform to git what files or paths were altered, with the add command. Then, you
need to commit those changes, being a good practice to indicate with a short
text what was worked on. Full documentation on git commit's can be found
\href{https://git-scm.com/docs/git-commit}{here.}  
\begin{lstlisting}[language=bash]
# suppose you edit a file named test.txt
git add test.txt
# if more files were altered:
git add test.txt test2.txt
# to commit all changes simply
git commit -m "Commit message"
# if a path was altered, you can add and commit
# it at the same time, without affecting
# the previous changes
git commit -m "What was changed" General_test
\end{lstlisting}
\begin{tipbox}
You can commit directly all altered files with the -a flag. Keep in mind this
doesn't affect new files that git doesn't knows about.
\end{tipbox}
Let's suppose you forgot to add a file on the commit. You can then amend that
commit, generating a commit that will replace the results of the first.
\begin{lstlisting}[language=bash]
git add what_you_forgot
git commit --amend
\end{lstlisting}
Now, you still have the same files and structure on the main branch of the
repository, but a whole new view on your work branch. Let's say your work on
this new branch is done, and can now be incremented to the main structure. You
need first to go back to the master branch, and then perform what we call
a branch merge. After all, usually the created branch, now merged, is deleted,
aiming to keep directory organization.
\begin{lstlisting}[language=bash]
git checkout master # switch branch
git merge new_branch_name # performs the merge
git branch -d new_branch_name # deletes older branch
\end{lstlisting}
But, what about the files themselves that were altered? How do we send them to
the remote repository, if the changes occurred locally? Simple. We push.
\begin{lstlisting}[language=bash]
git push REMOTE-NAME BRANCH-NAME
\end{lstlisting}
In the case we were using above, we would:
\begin{lstlisting}[language=bash]
git push origin main
\end{lstlisting}
Further information on push usage can be found on the
\href{https://docs.github.com/en/get-started/using-git/pushing-commits-to-a-remote-repository}{github
push documentation.} 
\begin{remarkbox}
The opposite to pushing, is pulling. You can pull changes from given remote
repository to the current branch. If the current is behind, it gets updated. If
divergences are found, the user must specify how they should be approached.
For further comprehension on command usage, please refer to the
\href{https://git-scm.com/docs/git-pull}{git documentation.} 
\end{remarkbox}
\subsection{Useful commands}
\begin{cheatsheetbox}
\textbf{Command:} \texttt{add} \\
\textbf{Description:} Stage certain files for the current commit.
\noindent\makebox[\linewidth]{\dotfill}
\textbf{Command:} \texttt{clone} \\
\textbf{Description:} Clones to local work space the given repository.
\noindent\makebox[\linewidth]{\dotfill}
\textbf{Command:} \texttt{commit} \\
\textbf{Description:} Marks staged changes of remote repository to the current
branch snapshot.
\noindent\makebox[\linewidth]{\dotfill}
\textbf{Command:} \texttt{pull} \\
\textbf{Description:} Fetches changes of a remote repository to the current
branch.
\noindent\makebox[\linewidth]{\dotfill}
\textbf{Command:} \texttt{push} \\
\textbf{Description:} Sends local changes to the remote repository.
\noindent\makebox[\linewidth]{\dotfill}
\textbf{Command:} \texttt{status} \\
\textbf{Description:} Print current local repository status, like current branch
and summary of changes.
\end{cheatsheetbox}
\section{Conda}
When working actively with bioinformatics pipelines, software version management
and compatibility quickly becomes a major issue, requiring close attention in
order to avoid errors and issues that could affect the correct system operation.
With this in mind, Conda appears with the intent to minimize or solve completely
those issues. It is a command line tool aimed to package and environment
management, running in all base OS's available (Linux, mac and Windows).\par
Given it's importance and ease to use, for newcomers in the field, we shall
approach quickly conda's main topics and commands.
\subsection{Installation}
Although one can install directly conda from the source, two main minimal
installers are currently available. Their focus is on allowing a quick and
functional install of the core conda package. These are the
\href{https://www.anaconda.com/docs/getting-started/miniconda/main}{Miniconda}
and \href{https://conda-forge.org/download/}{Miniforge.} The first is related
directly to the Anaconda company, while the latter is community maintained. We
advise newcomers to first experience the software via the miniforge application,
given it's strong community and support. The next steps will be taken
considering you followed our advice.\par
Detailed installation directions can be found on the
\href{https://github.com/conda-forge/miniforge}{miniforge github page}.
We need to replicate the files and structure of the software for it to correctly
operate. Happily, this don't need to be done manually. The complete installation
and initial setup is realized entirely via the available bash file, that we can
obtain with terminal command call or downloading straight from the github
source.
\begin{lstlisting}[language=bash]
curl -L -O "https://github.com/conda-forge/miniforge/releases \
/latest/download/Miniforge3-$(uname)-$(uname -m).sh"
# or
wget "https://github.com/conda-forge/miniforge/releases \ 
/latest/download/Miniforge3-$(uname)-$(uname -m).sh"
# to install simply run the script
bash Miniforge3-$(uname)-$(uname -m).sh
\end{lstlisting}
\begin{remarkbox}
The uname and uname-m portions refer to the current version available of
miniforge. They can be altered to specific versions, though not recommended.
\end{remarkbox}
After the install, it shall ask you, the user, if auto start should be
available. For ease of use, we recommend so, although it remains totally as
a personal choice. This way, the initialization of the base conda environment is
added to the .bashrc file and to the PATH environment, allowing to be called
from any terminal window. To check if all worked as intended, you can run the
following command:
\begin{lstlisting}[language=bash]
conda --help
\end{lstlisting}
If a summary list of the available options shows up, everything is working as
intended. You can also see that, on new terminal windows or by resourcing
.bashrc the tag (base) shows up before the usual terminal header. This tag
indicates the active conda environment. 
\begin{definitionbox}
    An \textbf{environment} can be seen as a sub system inside your main one. It
    store certain packages and applications on specific versions and can be
    activated or deactivated. In that way, one can better manage dependencies
    and avoid major inconveniences on package installation and maintenance.
\end{definitionbox}
\subsection{General usage}
\subsection{Useful commands}

\section{}


\section{Tools \& Software}

\subsection{Required Software}
\sn{Installation notes}

\begin{itemize}
    \item \textbf{Primary tool:} Tool name and version
    \item \textbf{Dependencies:} Required libraries/packages
    \item \textbf{Optional:} Additional helpful tools
\end{itemize}

\subsection{Installation Guide}
\begin{lstlisting}[language=bash, caption=Software installation]
# Installation commands
conda install -c bioconda tool_name
# or
sudo apt-get install package_name
\end{lstlisting}

\section{Workflow \& Methods}

\subsection{Step-by-Step Protocol}
\sn{Key parameters}

\begin{enumerate}
    \item \textbf{Data preparation:} Input requirements and formatting
    \item \textbf{Quality control:} Initial data assessment
    \item \textbf{Main analysis:} Core computational steps
    \item \textbf{Result interpretation:} Output analysis and validation
\end{enumerate}

\begin{example}
Practical example with real genomic data.
\end{example}

\section{Practical Examples}

\subsection{Example 1: Basic Analysis}
\sn{Input/output files}

\begin{itemize}
    \item \textbf{Input:} Sample data description
    \item \textbf{Command:} Based on approach from \cite{example2024}
    \item \textbf{Output:} Expected results and file formats
\end{itemize}

\begin{lstlisting}[language=bash, caption=Basic command example]
# Example command with typical genomic data
tool_name -i input_file.fasta -o output_file.txt --parameter value
\end{lstlisting}

\subsection{Example 2: Advanced Usage}
\sn{Complex parameters}

\begin{lstlisting}[language=bash, caption=Advanced analysis pipeline]
# Multi-step analysis pipeline
step1_tool input.fasta | step2_tool --param1 value1 > intermediate.txt
step3_tool intermediate.txt --param2 value2 -o final_result.txt
\end{lstlisting}

\section{Results \& Interpretation}

\subsection{Output Files}
\sn{File formats}

Common output formats and their interpretation:
\begin{itemize}
    \item \textbf{Format 1:} Description and typical contents
    \item \textbf{Format 2:} When and how to use this output
    \item \textbf{Quality metrics:} How to assess result quality
\end{itemize}

\begin{remark}
Important note about result interpretation following \citet{author2024}.
\end{remark}

\section{Scripts \& Code}

\subsection{Helper Scripts}
\begin{lstlisting}[language=Python, caption=Data processing script]
#!/usr/bin/env python3
"""
Helper script for genomic data processing
Usage: python script.py input.fasta output.txt
"""

def process_sequences(input_file, output_file):
    """Process genomic sequences"""
    with open(input_file, 'r') as f:
        sequences = f.read()
    
    # Processing logic here
    processed = sequences.upper()
    
    with open(output_file, 'w') as f:
        f.write(processed)

if __name__ == "__main__":
    import sys
    process_sequences(sys.argv[1], sys.argv[2])
\end{lstlisting}

\subsection{Quality Control}
\begin{lstlisting}[language=bash, caption=QC pipeline]
#!/bin/bash
# Quality control pipeline for genomic data

# Check file format
file_format_check.py $INPUT_FILE

# Basic statistics
sequence_stats.py $INPUT_FILE > stats.txt

# Quality assessment
quality_assessment_tool $INPUT_FILE --output qc_report.html
\end{lstlisting}

\section{Troubleshooting \& Best Practices}

\subsection{Common Issues}
\sn{Error solutions}

\begin{itemize}
    \item \textbf{Memory errors:} Reduce dataset size or increase available RAM
    \item \textbf{Format issues:} Check input file formatting and encoding
    \item \textbf{Parameter tuning:} Guidelines for optimization
\end{itemize}

\subsection{Best Practices}
\begin{itemize}
    \item \textbf{Data backup:} Always keep original data copies
    \item \textbf{Version control:} Track analysis versions and parameters
    \item \textbf{Documentation:} Record all analysis steps and decisions
    \item \textbf{Reproducibility:} Use consistent environments and seeds
\end{itemize}

\begin{references}
    \item Key papers: \cite{example2024,author2024,smith2024}
    \item Software documentation: [Tool official docs]
    \item Related modules: [Other workflow modules]
\end{references}

\section{Exercises \& Next Steps}

\begin{itemize}
    \item \todo{Practice with provided sample data}
    \item \todo{Try different parameter settings}
    \item \important{Apply to your own genomic dataset}
    \item \todo{Explore advanced features}
\end{itemize}

\begin{notes}
Additional observations and module-specific notes...

\highlight{Key insight}: Connection between this tool and genome annotation pipeline

\idea{Extension}: Integration with other bioinformatics tools in the workflow

\end{notes}

% BIBLIOGRAPHY
\newpage
\printbibliography

\end{document}
