% Genomes Workflow Module Template - LBCM UFRGS
% Based on NotesTeX and Gilles Castel's aesthetic approach
% Module: 01 - General guidelines and workflow organization
% Date: DATE_PLACEHOLDER

\documentclass[a4paper,11pt]{article}

% Use ONLY the beautiful notes preamble for notes
\input{preamble.tex}

\title{
    \vfill
    \textcolor{noteblue}{\Huge Genomes Workflow - LBCM}\\
    \vspace{5.0cm}
    \textcolor{sidenotegray}{\huge 01 - General guidelines and workflow organization}\\
    \vspace{1.5cm}
    \textcolor{sidenotegray}{\LARGE }\\
    \vspace{5.0cm}
    \textcolor{sidenotegray}{\large \today}
    \vfill
}
\author{}
\date{}

\begin{document}

\maketitle
\thispagestyle{empty}
\newpage
\tableofcontents
\newpage
\section{Overview}

\subsection{Module Objectives}
\sn{Learning goals}

This module covers:
\begin{itemize}
    \item Basic Linux terminal concepts and usage.
    \item What is git and basic usage.
    \item Conda environment logic.
    \item Conda basic usage.
    \item Recommended bioinformatics project organization.
\end{itemize}

\section{The Linux question}
Taking in consideration the variety of tools available, their functionalities
and general comprehension around systems and workflow organization, the choice
of operational system constitutes a central point. \par 
In multiple fronts, Linux get's the spotlight. One big advantage is the cost to
install and implement the OS: Zero. With a GPL License, everyone has the right
to change and redistribute it, following the condition that the code should stay
available (\cite{garrelsIntroductionLinux2008}). It's portability, security and
the existence of a large and committed community all helps on the final OS
choice for general Bioinformatics research projects.\par
In the current chapter, we intend to present basics concepts of the Linux
ecosystem. Terminal operation will also be included, since it's intrinsic
relation to the system core functionalities. Finally, a brief Linux Mint
presentation and guidelines shall be pointed, as it's the initial distro of
choice.\par
\begin{remarkbox}
    For further and in depth comprehension of base Linux related topics, it is
    advised to check \cite{garrelsIntroductionLinux2008}.
\end{remarkbox}
\subsection{So... What is it?}
With the crescent wave on tech development, the fact that some systems were
directly developed for specific hardware started to weight a ton on user
instruction and final cost of the products. A team of developers then started
working on what would come to be the \textbf{"UNIX"} project. This operational system
brought to the table the ability of code to be recycled, the use of
a higher programming language then assembly (C) and an unique overall
simplicity (\cite{garrelsIntroductionLinux2008}).\par
\begin{definitionbox}
   UNIX refers to a family of operational systems based on the final product of
   the original UNIX project. They aim to be simple, elegant and allow code
   recycling. To achieve their goals, modular logic is applied, alongside
   a hierarchical file system and innate command line interface. 
\end{definitionbox}
Then, home PC's started getting traction, in a way that running UNIX on them
became a possibility. In this context, the idea of a free system directly
connected to the original \textbf{UNIX} would led to the birth of \textbf{Linux}
as a freely available OS.
\begin{definitionbox}
    Linux is an open source OS based on UNIX. Is composed mainly by
    (\cite{WhatLinux2025}):
    \begin{description}
        \item[Bootloader:] Manages the boot process of the computer.
        \item[Kernel:] The actual \textbf{Linux}. Manages the CPU, memory and
            peripheral devices.
        \item[Initialization system:] Sub-system that controls daemons.
        \item[Daemons:] Background services started up during or after boot.
        \item[Graphical server:] Sub-system for graphical display.
        \item[Desktop environment:] Interfaces for direct user interaction.
        \item[Applications:] Any software that can be installed on the system
            and offer some service or act as a tool.
    \end{description}
\end{definitionbox}
\subsection{Choosing a Distro}
\subsection{Command Line and Terminal operation}
When using Linux based OS's, one specific "feature" get's the spotlight on the
eyes of newcomers: the command line. Basically all tasks done via GUI's can be
also executed via command line, usually mediated with a terminal interface.\par
Taking this in mind, understanding the relevance and basic navigation of the
command line, allows an overall better and more efficient system operation. In
this sense, the present section aims to establish broad concepts and present
general guidelines on the subject.
\begin{definitionbox}
    The term command line, actually refers to the \textbf{shell}. It consists in
    a program whose purpose is to take keyboard commands and direct them to the
    OS for execution. In Linux systems, the core \textbf{shell} usually is
    \textbf{bash}. \textbf{Terminals} are interfaces that allow users with a GUI to
    interact with the \textbf{shell}(\cite{shottsLinuxCommandLine2024}).
\end{definitionbox}
\subsubsection{Basics}
Nothing better to learn than getting punched by the subject. Let's experiment
with basic terminal manipulation and usage. This section is an adaptation of the
first chapter of \cite{shotssLinuxCommandLine2024}, in that sense, for further
comprehension on the subject, please refer to the main source.\par
First, open the terminal window (Ctrl+Alt+T on Linux Mint). What you are now
seeing, I hope so, is something like:
\begin{lstlisting}[language=bash]
   [user@machine ~]$ 
\end{lstlisting}
Or, if using conda, probably something like:
\begin{lstlisting}[language=bash]
   (base)[user@machine ~]$ 
\end{lstlisting}
This is what we call the shell prompt, indicating that it's ready to receive
orders. It informs you the current user name, the machine name and the current
directory. Knowledge of the directory currently set is of extreme importance,
and will be discussed on the next topic.\par
Now, type out on the terminal the following:
\begin{lstlisting}[language=bash]
   [user@machine ~]$ ls
\end{lstlisting}
The expected output, is a listing of all files and folders available
\textbf{directly} on the current work directory (I said it was important). Done,
you executed your first bash command! The majority of commands supports what we
call \textbf{arguments}, that can be present in different forms, like
\textbf{flags}, \textbf{parameters} and \textbf{positional}. Let's try it out:
\begin{lstlisting}[language=bash]
   [user@machine ~]$ ls -a
\end{lstlisting}
\begin{definitionbox}
    \begin{description}
        \item[Argument:] A value, whose format can vary, that informs something
            to the program that will be executed. In this way, he allows more
            interaction and control of the user with the command itself.
        \item[Flag:] A flag consists in an argument that doesn't have a value.
            It usually appears in the format of a single dash followed by a letter
            (-l, -a, etc).
        \item[Parameter:] A parameter is an argument with an user determined
            value. The base format of a parameter is two dashes followed by
            a space and the value (like in -{}-help). In some cases, the space
            is substituted for a equality symbol (like in -{}-output=/home). 
        \item[Positional argument:] Indicates to the command which directory or
            file it should  seek and operate. Usually presents itself with
            a space from the rest of the arguments and the initial command
            followed by the path to needed directory or file.
    \end{description}
\end{definitionbox}
Now, you can see a lot more files are being shown. That's because the
\textbf{-a} flag indicates to the command that you want to see \textbf{all}
possible files and directories under the current work directory. So, now your
output will also include the hidden files, marked by the presence of a single
dot before the file name.\par
\begin{remarkbox}
In the majority of commands or terminal executed scripts, you can see a summary
of possible flags and operational directions for command usage applying the
-{}-help parameter or the -h flag.
\end{remarkbox}
\subsubsection{The file system tree}

\subsubsection{Navigating with the shell}

\subsubsection{Cheatsheet}



\subsection{Linux and Bioinformatics}

\section{Tools \& Software}

\subsection{Required Software}
\sn{Installation notes}

\begin{itemize}
    \item \textbf{Primary tool:} Tool name and version
    \item \textbf{Dependencies:} Required libraries/packages
    \item \textbf{Optional:} Additional helpful tools
\end{itemize}

\subsection{Installation Guide}
\begin{lstlisting}[language=bash, caption=Software installation]
# Installation commands
conda install -c bioconda tool_name
# or
sudo apt-get install package_name
\end{lstlisting}

\section{Workflow \& Methods}

\subsection{Step-by-Step Protocol}
\sn{Key parameters}

\begin{enumerate}
    \item \textbf{Data preparation:} Input requirements and formatting
    \item \textbf{Quality control:} Initial data assessment
    \item \textbf{Main analysis:} Core computational steps
    \item \textbf{Result interpretation:} Output analysis and validation
\end{enumerate}

\begin{example}
Practical example with real genomic data.
\end{example}

\section{Practical Examples}

\subsection{Example 1: Basic Analysis}
\sn{Input/output files}

\begin{itemize}
    \item \textbf{Input:} Sample data description
    \item \textbf{Command:} Based on approach from \cite{example2024}
    \item \textbf{Output:} Expected results and file formats
\end{itemize}

\begin{lstlisting}[language=bash, caption=Basic command example]
# Example command with typical genomic data
tool_name -i input_file.fasta -o output_file.txt --parameter value
\end{lstlisting}

\subsection{Example 2: Advanced Usage}
\sn{Complex parameters}

\begin{lstlisting}[language=bash, caption=Advanced analysis pipeline]
# Multi-step analysis pipeline
step1_tool input.fasta | step2_tool --param1 value1 > intermediate.txt
step3_tool intermediate.txt --param2 value2 -o final_result.txt
\end{lstlisting}

\section{Results \& Interpretation}

\subsection{Output Files}
\sn{File formats}

Common output formats and their interpretation:
\begin{itemize}
    \item \textbf{Format 1:} Description and typical contents
    \item \textbf{Format 2:} When and how to use this output
    \item \textbf{Quality metrics:} How to assess result quality
\end{itemize}

\begin{remark}
Important note about result interpretation following \citet{author2024}.
\end{remark}

\section{Scripts \& Code}

\subsection{Helper Scripts}
\begin{lstlisting}[language=Python, caption=Data processing script]
#!/usr/bin/env python3
"""
Helper script for genomic data processing
Usage: python script.py input.fasta output.txt
"""

def process_sequences(input_file, output_file):
    """Process genomic sequences"""
    with open(input_file, 'r') as f:
        sequences = f.read()
    
    # Processing logic here
    processed = sequences.upper()
    
    with open(output_file, 'w') as f:
        f.write(processed)

if __name__ == "__main__":
    import sys
    process_sequences(sys.argv[1], sys.argv[2])
\end{lstlisting}

\subsection{Quality Control}
\begin{lstlisting}[language=bash, caption=QC pipeline]
#!/bin/bash
# Quality control pipeline for genomic data

# Check file format
file_format_check.py $INPUT_FILE

# Basic statistics
sequence_stats.py $INPUT_FILE > stats.txt

# Quality assessment
quality_assessment_tool $INPUT_FILE --output qc_report.html
\end{lstlisting}

\section{Troubleshooting \& Best Practices}

\subsection{Common Issues}
\sn{Error solutions}

\begin{itemize}
    \item \textbf{Memory errors:} Reduce dataset size or increase available RAM
    \item \textbf{Format issues:} Check input file formatting and encoding
    \item \textbf{Parameter tuning:} Guidelines for optimization
\end{itemize}

\subsection{Best Practices}
\begin{itemize}
    \item \textbf{Data backup:} Always keep original data copies
    \item \textbf{Version control:} Track analysis versions and parameters
    \item \textbf{Documentation:} Record all analysis steps and decisions
    \item \textbf{Reproducibility:} Use consistent environments and seeds
\end{itemize}

\begin{references}
    \item Key papers: \cite{example2024,author2024,smith2024}
    \item Software documentation: [Tool official docs]
    \item Related modules: [Other workflow modules]
\end{references}

\section{Exercises \& Next Steps}

\begin{itemize}
    \item \todo{Practice with provided sample data}
    \item \todo{Try different parameter settings}
    \item \important{Apply to your own genomic dataset}
    \item \todo{Explore advanced features}
\end{itemize}

\begin{notes}
Additional observations and module-specific notes...

\highlight{Key insight}: Connection between this tool and genome annotation pipeline

\idea{Extension}: Integration with other bioinformatics tools in the workflow

\end{notes}

% BIBLIOGRAPHY
\newpage
\printbibliography

\end{document}
