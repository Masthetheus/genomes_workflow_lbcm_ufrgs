% Genomes Workflow Module Template - LBCM UFRGS
% Based on NotesTeX and Gilles Castel's aesthetic approach
% Module: 01 - General guidelines and workflow organization
% Date: DATE_PLACEHOLDER

\documentclass[a4paper,11pt]{article}

% Use ONLY the beautiful notes preamble for notes
\input{preamble.tex}

\title{
    \vfill
    \textcolor{noteblue}{\Huge Genomes Workflow - LBCM}\\
    \vspace{5.0cm}
    \textcolor{sidenotegray}{\huge 01 - General guidelines and workflow organization}\\
    \vspace{1.5cm}
    \textcolor{sidenotegray}{\LARGE }\\
    \vspace{5.0cm}
    \textcolor{sidenotegray}{\large \today}
    \vfill
}
\author{}
\date{}

\begin{document}

\maketitle
\thispagestyle{empty}
\newpage
\tableofcontents
\newpage
\section{Overview}

\subsection{Module Objectives}
\sn{Learning goals}

This module covers:
\begin{itemize}
    \item Basic Linux terminal concepts and usage.
    \item What is git and basic usage.
    \item Conda environment logic.
    \item Conda basic usage.
    \item Recommended bioinformatics project organization.
\end{itemize}

\section{The Linux question}
Taking in consideration the variety of tools available, their functionalities
and general comprehension around systems and workflow organization, the choice
of operational system constitutes a central point. \par 
In multiple fronts, Linux get's the spotlight. One big advantage is the cost to
install and implement the OS: Zero. With a GPL License, everyone has the right
to change and redistribute it, following the condition that the code should stay
available (\cite{garrelsIntroductionLinux2008}). It's portability, security and
the existence of a large and committed community all helps on the final OS
choice for general Bioinformatics research projects.\par
In the current chapter, we intend to present basics concepts of the Linux
ecosystem. Terminal operation will also be included, since it's intrinsic
relation to the system core functionalities. Finally, a brief Linux Mint
presentation and guidelines shall be pointed, as it's the initial distro of
choice.\par
\begin{remarkbox}
    For further and in depth comprehension of base Linux related topics, it is
    advised to check \cite{garrelsIntroductionLinux2008}.
\end{remarkbox}
\subsection{So... What is it?}
With the crescent wave on tech development, the fact that some systems were
directly developed for specific hardware started to weight a ton on user
instruction and final cost of the products. A team of developers then started
working on what would come to be the \textbf{"UNIX"} project. This operational system
brought to the table the ability of code to be recycled, the use of
a higher programming language then assembly (C) and an unique overall
simplicity (\cite{garrelsIntroductionLinux2008}).\par
\begin{definitionbox}
   UNIX refers to a family of operational systems based on the final product of
   the original UNIX project. They aim to be simple, elegant and allow code
   recycling. To achieve their goals, modular logic is applied, alongside
   a hierarchical file system and innate command line interface. 
\end{definitionbox}
Then, home PC's started getting traction, in a way that running UNIX on them
became a possibility. In this context, the idea of a free system directly
connected to the original \textbf{UNIX} would led to the birth of \textbf{Linux}
as a freely available OS.
\begin{definitionbox}
    Linux is an open source OS based on UNIX. Is composed mainly by
    (\cite{WhatLinux2025}):
    \begin{description}
        \item[Bootloader:] Manages the boot process of the computer.
        \item[Kernel:] The actual \textbf{Linux}. Manages the CPU, memory and
            peripheral devices.
        \item[Initialization system:] Sub-system that controls daemons.
        \item[Daemons:] Background services started up during or after boot.
        \item[Graphical server:] Sub-system for graphical display.
        \item[Desktop environment:] Interfaces for direct user interaction.
        \item[Applications:] Any software that can be installed on the system
            and offer some service or act as a tool.
    \end{description}
\end{definitionbox}
\subsection{Choosing a Distro}
A lifelong debates inside the Linux community revolves around which  Linux
distribution to choose. One of the biggest reasons for such is that there's no
correct answer. Multiple factors interfere in the final choice, and it can be
largely personal too.\par
Across the internet, a variety of guides and lists can be found on the subject.
As it's not the central purpose of this project, we won't dive deeply in this
matter. But, even though this creative freedom was taken, we will still, in
a further chapter, approach one specific Linux distro, called Linux Mint. This
decision was made to lay a foundation for some installation instructions, that
can change based on the system of choice. Always when that's the case, it shall
be pointed out.\par
The choice of Mint itself was based purely on the fact that it is a distro with
large support, reach and with a more reasonable learning curve for Linux
newcomers.

\begin{tipbox}
    If you want to dive a little deeper on the Mint Distro, we recommend it's
    User Guide (\cite{mintUserGuideLinux2024}). In it, you can find informations
    on the system's update manager, multiboot, upgrades from older versions and
    so on. The online official documentation Linux Mint webpage presents in
    multiple format all available guides (\cite{mintLinuxMintDocumentation2025}). 
\end{tipbox}


\subsubsection{Installing Mint}

\subsection{Command Line and Terminal operation}
When using Linux based OS's, one specific "feature" get's the spotlight on the
eyes of newcomers: the command line. Basically all tasks done via GUI's can be
also executed via command line, usually mediated with a terminal interface.\par
Taking this in mind, understanding the relevance and basic navigation of the
command line, allows an overall better and more efficient system operation. In
this sense, the present section aims to establish broad concepts and present
general guidelines on the subject.
\begin{definitionbox}
    The term command line, actually refers to the \textbf{shell}. It consists in
    a program whose purpose is to take keyboard commands and direct them to the
    OS for execution. In Linux systems, the core \textbf{shell} usually is
    \textbf{bash}. \textbf{Terminals} are interfaces that allow users with a GUI to
    interact with the \textbf{shell}(\cite{shottsLinuxCommandLine2024}).
\end{definitionbox}
\subsubsection{Basics}
Nothing better to learn than getting punched by the subject. Let's experiment
with basic terminal manipulation and usage. This section is an adaptation of the
first chapter of \cite{shotssLinuxCommandLine2024}, in that sense, for further
comprehension on the subject, please refer to the main source.\par
First, open the terminal window (Ctrl+Alt+T on Linux Mint). What you are now
seeing, I hope so, is something like:
\begin{lstlisting}[language=bash]
   [user@machine ~]$ 
\end{lstlisting}
Or, if using conda, probably something like:
\begin{lstlisting}[language=bash]
   (base)[user@machine ~]$ 
\end{lstlisting}
This is what we call the shell prompt, indicating that it's ready to receive
orders. It informs you the current user name, the machine name and the current
directory. Knowledge of the directory currently set is of extreme importance,
and will be discussed on the next topic.\par
Now, type out on the terminal the following:
\begin{lstlisting}[language=bash]
   [user@machine ~]$ ls
\end{lstlisting}
The expected output, is a listing of all files and folders available
\textbf{directly} on the current work directory (I said it was important). Done,
you executed your first bash command! The majority of commands supports what we
call \textbf{arguments}, that can be present in different forms, like
\textbf{flags}, \textbf{parameters} and \textbf{positional}. Let's try it out:
\begin{lstlisting}[language=bash]
   [user@machine ~]$ ls -a
\end{lstlisting}
\begin{definitionbox}
    \begin{description}
        \item[Argument:] A value, whose format can vary, that informs something
            to the program that will be executed. In this way, he allows more
            interaction and control of the user with the command itself.
        \item[Flag:] A flag consists in an argument that doesn't have a value.
            It usually appears in the format of a single dash followed by a letter
            (-l, -a, etc).
        \item[Parameter:] A parameter is an argument with an user determined
            value. The base format of a parameter is two dashes followed by
            a space and the value (like in -{}-help). In some cases, the space
            is substituted for a equality symbol (like in -{}-output=/home). 
        \item[Positional argument:] Indicates to the command which directory or
            file it should  seek and operate. Usually presents itself with
            a space from the rest of the arguments and the initial command
            followed by the path to needed directory or file.
    \end{description}
\end{definitionbox}
Now, you can see a lot more files are being shown. That's because the
\textbf{-a} flag indicates to the command that you want to see \textbf{all}
possible files and directories under the current work directory. So, now your
output will also include the hidden files, marked by the presence of a single
dot before the file name.\par
\begin{remarkbox}
In the majority of commands or terminal executed scripts, you can see a summary
of possible flags and operational directions for command usage applying the
-{}-help parameter or the -h flag.
\end{remarkbox}
\begin{tipbox}
    For better quality of life, you can use the up and down arrow keys to
    access the \textbf{terminal command history}. Try cycling through previous
    commands and re-running them.
\end{tipbox}
This covers up our initial contact with the shell and terminal. As a way of
saying goodbye, instead of closing the window in the traditional way, you can
exit the shell by simply typing the below!
\begin{lstlisting}[language=bash]
   [user@machine ~]$ exit 
\end{lstlisting}
\subsubsection{The file system tree}
Now, we are going to approach the file system tree of Linux based systems. The
tree analogy says it all, the files are organized in what's called
\textbf{hierarchical directory structure}(\cite{shottsLinuxCommandLine2024}). In
this sense, the system has a base for the tree, which we call the \textbf{root
directory}. All others directories, that we can think as branches, and files,
the leaves,  will be located inside this root.
\begin{remarkbox}
    Unix-like systems approach storage devices in a particular way. They're
    treated as part of the single file system tree that begins on the root. That
    being, any storage device that is connected to the system, is being
    \textbf{mounted} in certain \textbf{point}(location) inside the main tree.
\end{remarkbox}
Below you can see some of the root base sub-directories
(\cite{garrelsIntroductionLinux2008}).
\begin{definitionbox}
    \begin{description}
        \item [bin:] Programs shared by the system, the system administrator and
            all of the users.
        \item [boot:] Stores the startup files and the kernel.
        \item [etc:] Stores the most important system configuration files.
        \item [home:] Acts as a "root" for the directories of common system 
            users.
        \item [lib:] Library files needed by the system and it's users.
        \item [mnt:] Standard mount point for all external file systems.
        \item [root:] The home directory of the system administrator.
        \item [tmp:] Used to store temporary files, being cleaned up on reboot.
        \item [usr:] Files and directories related to all user-related programs.
    \end{description}
\end{definitionbox}
\begin{remarkbox}
    \textbf{Caution!} The /root refers to the administrator home directory,
    while / refers to the root directory.
\end{remarkbox}
\subsubsection{Navigating with the shell}
Remember when was said that the current work directory is important? Now's the
time to understand why. As was presented on the previous sub-section, Linux based
systems operate on a single rooted file system. This implies that we can, from 
inside the terminal, access all existent sub-directories and files, but also,
that a hierarchical order is present. In this sense, we can conclude that the
terminal needs to know where he stands on this tree to operate in the intended
way.\par
When opening a new terminal window, we saw that after the machine name, the
\textbf{current working directory} is shown. This is where the terminal
stands on the tree. The logic of this is easier comprehended by
imagining as if we are at the CWD looking forward. We can see all connected
branches and the current branch leaves and operate on them and theirs
subsequent branches and leaves. We saw this with the ls command previously
tested. \par
Let's try some basic terminal navigation. Open a new terminal window (Ctrl+Alt+T on
Linux Mint). Let's check the current work directory we are on:

\begin{lstlisting}[language=bash]
   [user@machine ~]$ pwd
\end{lstlisting}
\begin{remarkbox}
    The \textasciitilde {} directory is a short way to refer to the current
    user home directory. It's the equivalent of /home/user/. You can test this
    by opening a terminal window and typing the \textbf{pwd} command, that shows
    the name of the current WD.
\end{remarkbox}
If all worked as supposed to, the current WD was shown on the screen. Great!
Now, let's create a test directory inside the current one and make it our new
WD. After that, let's run again the pwd command.
\begin{lstlisting}[language=bash]
   mkdir test
   cd test
   pwd
\end{lstlisting}
First, we used \textbf{mkdir} with the argument 'test' to create a new
sub-directory called test. Then, the \textbf{cd} command allowed us to change
our WD to the one specified as an argument, in this case 'test'. The output of
\textbf{pwd} shows that we did, indeed, change the current "point of view" of
our shell session.\par
Still in this terminal, try to change again to the test folder. As you can see,
the bash returns a message saying that he wasn't able to find such file or
directory. This is because it really doesn't exists! At least not inside the WD.
Remember, the Linux file system is hierarchical. In this sense, the command
searches and operates based on the current work directory, seeing only the
branches and leaves that are "inside" of it. This is extremely relevant, for
when running scripts or other commands from a terminal, we need to make sure the
correct WD is set, because other way, the shell call won't be able to find and
operate on the intended files and directories.
\begin{tipbox}
    The cd usage can be simplified in some cases. If we want to go back to the
    user home directory, we can use:
\begin{lstlisting}[language=bash]
  cd ~ 
\end{lstlisting}
    Also, the parent folder can be referred as two dots (..). Using this we can:
\begin{lstlisting}[language=bash]
   cd .. # goes up one parent folder
   cd ../.. # goes up two parent folders, and so on 
\end{lstlisting}
\end{tipbox}
\begin{remarkbox}
    Linux based systems have what is called a \textbf{PATH environment
    variable}. This consists on a system variable that can be changed if
    necessary that contains a list of system paths. Anytime a shell session
    begins and any command is executed, the system searches not only the  WD
    and it's sub-directories and files, but also the paths included in this
    environment variable.
\end{remarkbox}
\subsubsection{Commands}
Aiming to provide some base commands, the user can see the cheat sheet below. In
depth command usage, availability and functionality can be found on software or
distribution documentation.
\begin{cheatsheetbox}
\textbf{Command:} \texttt{ls} \\
\textbf{Description:} List files in current work directory.
\noindent\makebox[\linewidth]{\dotfill}
\textbf{Command:} \texttt{pwd} \\
\textbf{Description:} List current work directory.
\noindent\makebox[\linewidth]{\dotfill}
\textbf{Command:} \texttt{cd 'new-directory'} \\
\textbf{Description:} Changes current work directory.
\noindent\makebox[\linewidth]{\dotfill}
\textbf{Command:} \texttt{mkdir 'new-directory'} \\
\textbf{Description:} Creates new directory inside current WD or on given path.
\noindent\makebox[\linewidth]{\dotfill}
\textbf{Command:} \texttt{cp 'file' 'copy-location'} \\
\textbf{Description:} Creates a copy of certain files inside the given 
location.
\noindent\makebox[\linewidth]{\dotfill}
\textbf{Command:} \texttt{mv 'current-location' 'new-location'} \\
\textbf{Description:} Moves a file inside the file system.
\noindent\makebox[\linewidth]{\dotfill}
\textbf{Command:} \texttt{df} \\
\textbf{Description:} Show current amount of free space on the disk drives.
\noindent\makebox[\linewidth]{\dotfill}
\textbf{Command:} \texttt{lsblk} \\
\textbf{Description:} Show current mounted disks and their mount points.
\noindent\makebox[\linewidth]{\dotfill}
\textbf{Command:} \texttt{rm 'file-path'} \\
\textbf{Description:} Removes the file indicated.
\end{cheatsheetbox}

\section{Git}

\section{Conda}

\section{}


\section{Tools \& Software}

\subsection{Required Software}
\sn{Installation notes}

\begin{itemize}
    \item \textbf{Primary tool:} Tool name and version
    \item \textbf{Dependencies:} Required libraries/packages
    \item \textbf{Optional:} Additional helpful tools
\end{itemize}

\subsection{Installation Guide}
\begin{lstlisting}[language=bash, caption=Software installation]
# Installation commands
conda install -c bioconda tool_name
# or
sudo apt-get install package_name
\end{lstlisting}

\section{Workflow \& Methods}

\subsection{Step-by-Step Protocol}
\sn{Key parameters}

\begin{enumerate}
    \item \textbf{Data preparation:} Input requirements and formatting
    \item \textbf{Quality control:} Initial data assessment
    \item \textbf{Main analysis:} Core computational steps
    \item \textbf{Result interpretation:} Output analysis and validation
\end{enumerate}

\begin{example}
Practical example with real genomic data.
\end{example}

\section{Practical Examples}

\subsection{Example 1: Basic Analysis}
\sn{Input/output files}

\begin{itemize}
    \item \textbf{Input:} Sample data description
    \item \textbf{Command:} Based on approach from \cite{example2024}
    \item \textbf{Output:} Expected results and file formats
\end{itemize}

\begin{lstlisting}[language=bash, caption=Basic command example]
# Example command with typical genomic data
tool_name -i input_file.fasta -o output_file.txt --parameter value
\end{lstlisting}

\subsection{Example 2: Advanced Usage}
\sn{Complex parameters}

\begin{lstlisting}[language=bash, caption=Advanced analysis pipeline]
# Multi-step analysis pipeline
step1_tool input.fasta | step2_tool --param1 value1 > intermediate.txt
step3_tool intermediate.txt --param2 value2 -o final_result.txt
\end{lstlisting}

\section{Results \& Interpretation}

\subsection{Output Files}
\sn{File formats}

Common output formats and their interpretation:
\begin{itemize}
    \item \textbf{Format 1:} Description and typical contents
    \item \textbf{Format 2:} When and how to use this output
    \item \textbf{Quality metrics:} How to assess result quality
\end{itemize}

\begin{remark}
Important note about result interpretation following \citet{author2024}.
\end{remark}

\section{Scripts \& Code}

\subsection{Helper Scripts}
\begin{lstlisting}[language=Python, caption=Data processing script]
#!/usr/bin/env python3
"""
Helper script for genomic data processing
Usage: python script.py input.fasta output.txt
"""

def process_sequences(input_file, output_file):
    """Process genomic sequences"""
    with open(input_file, 'r') as f:
        sequences = f.read()
    
    # Processing logic here
    processed = sequences.upper()
    
    with open(output_file, 'w') as f:
        f.write(processed)

if __name__ == "__main__":
    import sys
    process_sequences(sys.argv[1], sys.argv[2])
\end{lstlisting}

\subsection{Quality Control}
\begin{lstlisting}[language=bash, caption=QC pipeline]
#!/bin/bash
# Quality control pipeline for genomic data

# Check file format
file_format_check.py $INPUT_FILE

# Basic statistics
sequence_stats.py $INPUT_FILE > stats.txt

# Quality assessment
quality_assessment_tool $INPUT_FILE --output qc_report.html
\end{lstlisting}

\section{Troubleshooting \& Best Practices}

\subsection{Common Issues}
\sn{Error solutions}

\begin{itemize}
    \item \textbf{Memory errors:} Reduce dataset size or increase available RAM
    \item \textbf{Format issues:} Check input file formatting and encoding
    \item \textbf{Parameter tuning:} Guidelines for optimization
\end{itemize}

\subsection{Best Practices}
\begin{itemize}
    \item \textbf{Data backup:} Always keep original data copies
    \item \textbf{Version control:} Track analysis versions and parameters
    \item \textbf{Documentation:} Record all analysis steps and decisions
    \item \textbf{Reproducibility:} Use consistent environments and seeds
\end{itemize}

\begin{references}
    \item Key papers: \cite{example2024,author2024,smith2024}
    \item Software documentation: [Tool official docs]
    \item Related modules: [Other workflow modules]
\end{references}

\section{Exercises \& Next Steps}

\begin{itemize}
    \item \todo{Practice with provided sample data}
    \item \todo{Try different parameter settings}
    \item \important{Apply to your own genomic dataset}
    \item \todo{Explore advanced features}
\end{itemize}

\begin{notes}
Additional observations and module-specific notes...

\highlight{Key insight}: Connection between this tool and genome annotation pipeline

\idea{Extension}: Integration with other bioinformatics tools in the workflow

\end{notes}

% BIBLIOGRAPHY
\newpage
\printbibliography

\end{document}
